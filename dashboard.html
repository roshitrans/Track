<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live Driver Tracking - Roshi Transport</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Poppins', sans-serif; background: linear-gradient(135deg, #FFF8E7 0%, #F5E6D3 100%); min-height: 100vh; padding: 20px; transition: background 0.3s; }
        body.dark-mode { background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%); }
        .header { text-align: center; margin-bottom: 25px; padding: 20px; background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); border-radius: 15px; box-shadow: 0 6px 24px rgba(255, 165, 0, 0.25); position: relative; }
        .dark-toggle { position: absolute; right: 20px; top: 50%; transform: translateY(-50%); background: rgba(0,0,0,0.2); border: none; padding: 8px 12px; border-radius: 8px; cursor: pointer; font-size: 1.2em; transition: all 0.3s; }
        .dark-toggle:hover { background: rgba(0,0,0,0.3); transform: translateY(-50%) scale(1.1); }
        .header h1 { color: #2C1810; font-size: 2em; font-weight: 700; margin-bottom: 8px; }
        .live-indicator { display: inline-flex; align-items: center; gap: 8px; background: rgba(76, 175, 80, 0.2); padding: 5px 12px; border-radius: 15px; margin-top: 8px; }
        .live-dot { width: 8px; height: 8px; background: #4CAF50; border-radius: 50%; animation: pulse 1.5s infinite; }
        @keyframes pulse { 0%, 100% { opacity: 1; transform: scale(1); } 50% { opacity: 0.5; transform: scale(1.2); } }
        .live-text { color: #2C1810; font-size: 0.85em; font-weight: 600; }
        .stats-bar { display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 12px; margin-bottom: 25px; }
        .stat-card { background: white; padding: 16px; border-radius: 12px; box-shadow: 0 3px 12px rgba(0, 0, 0, 0.08); text-align: center; transition: all 0.3s; }
        body.dark-mode .stat-card { background: #333; color: #fff; }
        .stat-card:hover { transform: translateY(-2px); box-shadow: 0 6px 16px rgba(0, 0, 0, 0.12); }
        .stat-card h3 { color: #8D6E63; font-size: 0.8em; font-weight: 500; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; }
        body.dark-mode .stat-card h3 { color: #FFD700; }
        .stat-card p { color: #2C1810; font-size: 1.8em; font-weight: 700; transition: transform 0.2s; }
        body.dark-mode .stat-card p { color: #fff; }
        .stat-card .sub-text { font-size: 0.7em; color: #4CAF50; margin-top: 4px; font-weight: 500; }
        .main-container { display: flex; gap: 20px; align-items: stretch; }
        .map-container { flex: 1; background: white; border-radius: 15px; padding: 18px; box-shadow: 0 6px 24px rgba(0, 0, 0, 0.1); min-width: 0; }
        body.dark-mode .map-container { background: #333; }
        .map-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; flex-wrap: wrap; gap: 10px; }
        .map-header h2 { color: #2C1810; font-size: 1.3em; font-weight: 600; }
        body.dark-mode .map-header h2 { color: #FFD700; }
        .map-controls { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
        .refresh-btn { background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%); color: #2C1810; padding: 8px 16px; border: none; border-radius: 8px; font-family: 'Poppins', sans-serif; font-weight: 600; font-size: 0.85em; cursor: pointer; transition: all 0.3s ease; white-space: nowrap; }
        .refresh-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 12px rgba(255, 165, 0, 0.3); }
        .refresh-btn:disabled { opacity: 0.6; cursor: not-allowed; }
        .interval-selector { background: white; border: 2px solid #FFE4B5; padding: 6px 10px; border-radius: 8px; font-family: 'Poppins', sans-serif; font-size: 0.8em; cursor: pointer; }
        body.dark-mode .interval-selector { background: #444; color: #fff; border-color: #FFD700; }
        #map { height: 550px; border-radius: 12px; border: 2px solid #FFE4B5; }
        body.dark-mode #map { border-color: #FFD700; }
        .sidebar { width: 380px; background: white; border-radius: 15px; padding: 20px; box-shadow: 0 6px 24px rgba(0, 0, 0, 0.1); max-height: 680px; overflow-y: auto; transition: all 0.3s; }
        body.dark-mode .sidebar { background: #333; }
        .sidebar::-webkit-scrollbar { width: 8px; }
        .sidebar::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        body.dark-mode .sidebar::-webkit-scrollbar-track { background: #444; }
        .sidebar::-webkit-scrollbar-thumb { background: #FFD700; border-radius: 10px; }
        .sidebar::-webkit-scrollbar-thumb:hover { background: #FFA500; }
        .sidebar-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 18px; padding-bottom: 12px; border-bottom: 2px solid #FFE4B5; }
        body.dark-mode .sidebar-header { border-bottom-color: #FFD700; }
        .sidebar-header h2 { color: #2C1810; font-size: 1.3em; font-weight: 600; }
        body.dark-mode .sidebar-header h2 { color: #FFD700; }
        .driver-list { display: flex; flex-direction: column; gap: 12px; }
        .driver-card { background: linear-gradient(135deg, #FFFBF0 0%, #FFF8E7 100%); border: 2px solid #FFE4B5; border-radius: 10px; padding: 14px; transition: all 0.3s ease; position: relative; overflow: hidden; }
        body.dark-mode .driver-card { background: linear-gradient(135deg, #2a2a2a 0%, #1f1f1f 100%); border-color: #FFD700; }
        .driver-card::before { content: ''; position: absolute; top: 0; left: 0; width: 4px; height: 100%; background: #4CAF50; transition: background 0.5s ease; }
        .driver-card.tracking::before { background: #4CAF50; }
        .driver-card.stopped::before { background: #757575; }
        .driver-card:hover { transform: translateX(-3px); box-shadow: 0 4px 16px rgba(255, 165, 0, 0.2); border-color: #FFD700; }
        .driver-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px; }
        .driver-info h3 { color: #2C1810; font-size: 1em; font-weight: 600; margin-bottom: 3px; }
        body.dark-mode .driver-info h3 { color: #FFD700; }
        .driver-info p { color: #8D6E63; font-size: 0.8em; }
        body.dark-mode .driver-info p { color: #ccc; }
        .status-badge { padding: 4px 10px; border-radius: 12px; font-size: 0.7em; font-weight: 600; text-transform: uppercase; white-space: nowrap; }
        .status-tracking { background: #4CAF50; color: white; }
        .status-stopped { background: #757575; color: white; }
        .driver-details { font-size: 0.8em; color: #5D4037; margin-bottom: 10px; }
        body.dark-mode .driver-details { color: #ccc; }
        .driver-details div { margin-bottom: 3px; }
        .time-fresh { color: #4CAF50; font-weight: 600; }
        .time-stale { color: #FF9800; font-weight: 600; }
        .driver-actions { display: flex; gap: 6px; }
        .action-btn { flex: 1; padding: 6px 10px; border: none; border-radius: 6px; font-family: 'Poppins', sans-serif; font-size: 0.75em; font-weight: 600; cursor: pointer; transition: all 0.3s ease; text-align: center; }
        .btn-focus { background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%); color: white; }
        .btn-focus:hover { transform: translateY(-2px); box-shadow: 0 3px 10px rgba(33, 150, 243, 0.3); }
        .empty-state { text-align: center; padding: 30px 15px; color: #8D6E63; }
        body.dark-mode .empty-state { color: #ccc; }
        .empty-state p { font-size: 0.95em; margin-bottom: 8px; }
        .connection-error { background: #FFEBEE; color: #C62828; padding: 10px; border-radius: 8px; text-align: center; font-size: 0.85em; font-weight: 500; margin-bottom: 12px; }
        body.dark-mode .connection-error { background: #3a1f1f; color: #FF6B6B; }
        footer { text-align: center; color: #8D6E63; font-size: 0.8em; margin-top: 20px; }
        body.dark-mode footer { color: #ccc; }
        @media (max-width: 1200px) { .main-container { flex-direction: column; } .sidebar { width: 100%; max-height: 400px; } #map { height: 450px; } }
        @media (max-width: 768px) { .header h1 { font-size: 1.5em; } .stats-bar { grid-template-columns: repeat(2, 1fr); } #map { height: 350px; } .sidebar { max-height: 350px; } }
    </style>
</head>
<body>
    <div class="header">
        <button class="dark-toggle" onclick="toggleDarkMode()" title="Toggle Dark Mode">üåì</button>
        <h1>üöö Live Driver Tracking</h1>
        <div class="live-indicator"><div class="live-dot"></div><span class="live-text">LIVE DASHBOARD</span></div>
        <p style="margin-top: 6px; color: #5D4037; font-size: 0.9em;">Roshi Transport Corporation</p>
    </div>

    <div class="stats-bar">
        <div class="stat-card"><h3>Total Drivers</h3><p id="totalCount">0</p><div class="sub-text">On System</div></div>
        <div class="stat-card"><h3>Tracking</h3><p id="trackingCount">0</p><div class="sub-text">Active</div></div>
        <div class="stat-card"><h3>Stopped</h3><p id="stoppedCount">0</p><div class="sub-text">Inactive</div></div>
        <div class="stat-card"><h3>Next Update</h3><p id="countdown" style="font-size: 1.4em;">--</p><div class="sub-text" id="lastUpdateTime">Never</div></div>
    </div>

    <div class="main-container">
        <div class="map-container">
            <div class="map-header">
                <h2>üó∫Ô∏è Real-Time Map</h2>
                <div class="map-controls">
                    <select class="interval-selector" id="intervalSelector" onchange="changeRefreshInterval()">
                        <option value="5000" selected>Refresh: 5s</option>
                        <option value="10000">Refresh: 10s</option>
                        <option value="15000">Refresh: 15s</option>
                        <option value="30000">Refresh: 30s</option>
                    </select>
                    <button class="refresh-btn" id="refreshBtn" onclick="manualRefresh()">üîÑ Refresh Now</button>
                </div>
            </div>
            <div id="map"></div>
        </div>

        <div class="sidebar">
            <div class="sidebar-header"><h2>üìã Driver List</h2></div>
            <div id="connectionError" style="display: none;" class="connection-error">‚ö†Ô∏è Connection lost. Retrying...</div>
            <div class="driver-list" id="driverList">
                <div class="empty-state"><p>‚è≥ Initializing...</p><p style="font-size: 0.8em;">Connecting to live feed</p></div>
            </div>
        </div>
    </div>

    <footer><p>¬© 2024 Roshi Transport Corporation ‚Ä¢ Read-Only Live Dashboard</p></footer>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        const API_ENDPOINT = 'https://script.google.com/macros/s/AKfycbxyirlhBcpliW0APbADmCc4Uhqmr2JGPyELFY8Jw1unHys7P-0Eu7Ooi3rFCFX6dFLv2w/exec';
        let REFRESH_INTERVAL = 5000;
        let map, markers = {}, polylines = {}, routes = {}, currentDrivers = {};
        let refreshIntervalId, countdownIntervalId, nextRefreshTime = 0;
        let isFirstLoad = true, consecutiveErrors = 0;

        function initMap() {
            map = L.map('map').setView([20.5937, 78.9629], 5);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors',
                maxZoom: 19
            }).addTo(map);
        }

        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            localStorage.setItem('darkMode', document.body.classList.contains('dark-mode'));
        }

        if (localStorage.getItem('darkMode') === 'true') document.body.classList.add('dark-mode');

        async function fetchDriverData() {
            try {
                const response = await fetch(API_ENDPOINT, { method: 'GET', cache: 'no-cache' });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                if (!data.success) throw new Error(data.error || 'API error');
                consecutiveErrors = 0;
                hideConnectionError();
                return data.drivers || [];
            } catch (error) {
                console.error('Fetch error:', error);
                consecutiveErrors++;
                showConnectionError();
                return null;
            }
        }

        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371e3;
            const p1 = lat1 * Math.PI / 180, p2 = lat2 * Math.PI / 180;
            const dp = (lat2 - lat1) * Math.PI / 180, dl = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dp/2) * Math.sin(dp/2) + Math.cos(p1) * Math.cos(p2) * Math.sin(dl/2) * Math.sin(dl/2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        }

        function updateMap(drivers) {
            if (!drivers || drivers.length === 0) return;
            const currentPhones = new Set(), bounds = [];

            drivers.forEach(driver => {
                const phone = driver.phoneNumber;
                const lat = parseFloat(driver.latitude), lng = parseFloat(driver.longitude);
                if (isNaN(lat) || isNaN(lng) || lat < -90 || lat > 90 || lng < -180 || lng > 180) return;

                currentPhones.add(phone);
                bounds.push([lat, lng]);

                if (!routes[phone]) routes[phone] = [];
                const lastPoint = routes[phone][routes[phone].length - 1];
                if (!lastPoint || calculateDistance(lastPoint[0], lastPoint[1], lat, lng) > 5) {
                    routes[phone].push([lat, lng]);
                    if (routes[phone].length > 100) routes[phone].shift();
                }

                if (routes[phone].length > 1) {
                    const isStopped = driver.trackingState === 'STOPPED';
                    const color = isStopped ? '#9E9E9E' : '#2196F3';
                    if (polylines[phone]) {
                        polylines[phone].setLatLngs(routes[phone]);
                        polylines[phone].setStyle({ color, weight: 3, opacity: 0.6 });
                    } else {
                        polylines[phone] = L.polyline(routes[phone], { color, weight: 3, opacity: 0.6, smoothFactor: 1 }).addTo(map);
                    }
                }

                const isStopped = driver.trackingState === 'STOPPED';
                const markerColor = isStopped ? '#757575' : '#4CAF50';
                const icon = L.divIcon({
                    className: 'custom-marker',
                    html: `<div style="background: ${markerColor}; width: 28px; height: 28px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); transition: all 0.3s;"></div>`,
                    iconSize: [28, 28],
                    iconAnchor: [14, 14]
                });

                if (markers[phone]) {
                    markers[phone].setLatLng([lat, lng]);
                    markers[phone].setIcon(icon);
                } else {
                    markers[phone] = L.marker([lat, lng], { icon }).addTo(map);
                }

                const timeAgo = getTimeAgo(driver.lastUpdate);
                markers[phone].bindPopup(`<strong>${driver.driverName || 'Unknown'}</strong><br>üì± ${phone}<br>${isStopped ? 'üõë' : 'üü¢'} ${isStopped ? 'Stopped' : 'Tracking'}<br>‚è∞ ${timeAgo.text}`);
            });

            Object.keys(markers).forEach(phone => {
                if (!currentPhones.has(phone)) {
                    if (markers[phone]) { map.removeLayer(markers[phone]); delete markers[phone]; }
                    if (polylines[phone]) { map.removeLayer(polylines[phone]); delete polylines[phone]; }
                    delete routes[phone];
                }
            });

            if (isFirstLoad && bounds.length > 0) {
                map.fitBounds(bounds, { padding: [50, 50], maxZoom: 14 });
                isFirstLoad = false;
            }
        }

        function updateDriverList(drivers) {
            const container = document.getElementById('driverList');
            if (!drivers || drivers.length === 0) {
                container.innerHTML = '<div class="empty-state"><p>üì≠ No drivers available</p><p style="font-size: 0.8em;">Waiting for drivers...</p></div>';
                return;
            }

            const sorted = [...drivers].sort((a, b) => new Date(b.lastUpdate || 0) - new Date(a.lastUpdate || 0));
            const currentPhones = new Set(sorted.map(d => d.phoneNumber));

            container.querySelectorAll('.driver-card').forEach(card => {
                if (!currentPhones.has(card.dataset.phone)) {
                    card.style.opacity = '0';
                    card.style.transform = 'translateX(-20px)';
                    setTimeout(() => card.remove(), 300);
                }
            });

            sorted.forEach(driver => {
                const phone = driver.phoneNumber;
                let card = container.querySelector(`[data-phone="${phone}"]`);
                const isStopped = driver.trackingState === 'STOPPED';
                const timeAgo = getTimeAgo(driver.lastUpdate);

                if (card) {
                    card.className = `driver-card ${isStopped ? 'stopped' : 'tracking'}`;
                    card.querySelector('.status-badge').className = `status-badge ${isStopped ? 'status-stopped' : 'status-tracking'}`;
                    card.querySelector('.status-badge').textContent = isStopped ? 'Stopped' : 'Tracking';
                    const timeSpan = card.querySelector('.time-display');
                    if (timeSpan) {
                        timeSpan.className = timeAgo.fresh ? 'time-fresh' : 'time-stale';
                        timeSpan.textContent = timeAgo.text;
                    }
                } else {
                    card = document.createElement('div');
                    card.className = `driver-card ${isStopped ? 'stopped' : 'tracking'}`;
                    card.dataset.phone = phone;
                    card.innerHTML = `
                        <div class="driver-header">
                            <div class="driver-info">
                                <h3>${driver.driverName || 'Unknown'}</h3>
                                <p>üì± ${phone}</p>
                            </div>
                            <span class="status-badge ${isStopped ? 'status-stopped' : 'status-tracking'}">${isStopped ? 'Stopped' : 'Tracking'}</span>
                        </div>
                        <div class="driver-details">
                            <div>‚è∞ <span class="time-display ${timeAgo.fresh ? 'time-fresh' : 'time-stale'}">${timeAgo.text}</span></div>
                            <div>üìç ${driver.latitude.toFixed(5)}, ${driver.longitude.toFixed(5)}</div>
                            <div>üïê Started: ${formatTime(driver.sessionStart)}</div>
                        </div>
                        <div class="driver-actions">
                            <button class="action-btn btn-focus" onclick="focusDriver('${phone}')">View on Map</button>
                        </div>
                    `;
                    card.style.opacity = '0';
                    card.style.transform = 'translateY(15px)';
                    container.appendChild(card);
                    setTimeout(() => { card.style.opacity = '1'; card.style.transform = 'translateY(0)'; }, 50);
                }
            });
        }

        function focusDriver(phone) {
            if (markers[phone]) {
                const pos = markers[phone].getLatLng();
                map.setView(pos, 16, { animate: true });
                setTimeout(() => markers[phone].openPopup(), 500);
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        function updateStats(drivers) {
            const tracking = drivers.filter(d => d.trackingState !== 'STOPPED').length;
            const stopped = drivers.filter(d => d.trackingState === 'STOPPED').length;
            document.getElementById('totalCount').textContent = drivers.length;
            document.getElementById('trackingCount').textContent = tracking;
            document.getElementById('stoppedCount').textContent = stopped;
            document.getElementById('lastUpdateTime').textContent = new Date().toLocaleTimeString('en-IN');
        }

        function getTimeAgo(timestamp) {
            const diff = Math.floor((Date.now() - new Date(timestamp)) / 1000);
            if (diff < 10) return { text: 'Just now', fresh: true };
            if (diff < 60) return { text: `${diff}s ago`, fresh: true };
            if (diff < 3600) return { text: `${Math.floor(diff/60)}m ago`, fresh: diff < 300 };
            return { text: `${Math.floor(diff/3600)}h ago`, fresh: false };
        }

        function formatTime(iso) {
            if (!iso) return 'Unknown';
            return new Date(iso).toLocaleTimeString('en-IN', { hour: '2-digit', minute: '2-digit' });
        }

        function showConnectionError() {
            document.getElementById('connectionError').style.display = 'block';
        }

        function hideConnectionError() {
            document.getElementById('connectionError').style.display = 'none';
        }

        async function refreshData() {
            const drivers = await fetchDriverData();
            if (drivers) {
                updateStats(drivers);
                updateMap(drivers);
                updateDriverList(drivers);
                currentDrivers = drivers;
            }
            nextRefreshTime = Date.now() + REFRESH_INTERVAL;
        }

        async function manualRefresh() {
            const btn = document.getElementById('refreshBtn');
            btn.disabled = true;
            await refreshData();
            setTimeout(() => btn.disabled = false, 1000);
        }

        function changeRefreshInterval() {
            REFRESH_INTERVAL = parseInt(document.getElementById('intervalSelector').value);
            if (refreshIntervalId) clearInterval(refreshIntervalId);
            startAutoRefresh();
        }

        function startAutoRefresh() {
            refreshIntervalId = setInterval(refreshData, REFRESH_INTERVAL);
        }

        function startCountdown() {
            countdownIntervalId = setInterval(() => {
                const remaining = Math.max(0, Math.ceil((nextRefreshTime - Date.now()) / 1000));
                document.getElementById('countdown').textContent = remaining + 's';
            }, 100);
        }

        window.onload = () => {
            initMap();
            refreshData();
            startAutoRefresh();
            startCountdown();
        };

        window.onbeforeunload = () => {
            if (refreshIntervalId) clearInterval(refreshIntervalId);
            if (countdownIntervalId) clearInterval(countdownIntervalId);
        };
    </script>
</body>
</html>
